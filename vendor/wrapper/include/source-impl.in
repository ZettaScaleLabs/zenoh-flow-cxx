pub struct MySource;

impl Node for MySource {
    fn initialize(
        &self,
        configuration: &Option<Configuration>,
    ) -> ZFResult<State> {
        let cxx_configuration = match configuration {
            Some(config) => match config.as_object() {
                Some(config) => {
                    let mut conf = vec![];
                    for (key, value) in config {
                        let entry =  ffi::Configuration {
                            key: key.clone(),
                            value: value.as_str().ok_or_else(|| ZFError::GenericError)?.to_string(),
                        };
                        conf.push(entry);
                    }
                    conf
                }
                None => vec![],
            }

            None => vec![],
        };

        let state = {
            #[allow(unused_unsafe)]
            unsafe {
                ffi::initialize(&cxx_configuration)
            }
        };
        Ok(State::from(StateWrapper { state }))
    }

    fn finalize(&self, _state: &mut State) -> ZFResult<()> {
        Ok(())
    }
}

#[async_trait]
impl Source for MySource {
    async fn run(
        &self,
        context: &mut Context,
        dyn_state: &mut State,
    ) -> ZFResult<Data> {
        let mut cxx_context = ffi::Context::from(context);
        let wrapper = dyn_state.try_get::<StateWrapper>()?;

        let cxx_output = {
            #[allow(unused_unsafe)]
            unsafe {
                ffi::run(&mut cxx_context, &mut wrapper.state).map_err(|_| ZFError::GenericError)?
            }
        };
        Ok(Data::from_bytes(cxx_output))
    }
}

zenoh_flow::export_source!(register);

fn register() -> ZFResult<Arc<dyn Source>> {
    Ok(Arc::new(MySource) as Arc<dyn Source>)
}
