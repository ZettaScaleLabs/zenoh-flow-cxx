impl ffi::Token {
    pub fn from_token(token: &Token, port_id: &str) -> ZFResult<Self> {
        match token {
            Token::NotReady => Ok(Self {
                status: ffi::TokenStatus::Pending,
                action: ffi::TokenAction::Wait,
                port_id: port_id.to_string(),
                data: Vec::new(),
                timestamp: 0,
            }),

            Token::Ready(token) => {
                // let data = match &token.data.data {
                //     Data::Serialized(ser) => ser.as_ref().clone(),
                //     Data::Deserialized(de) => de.try_serialize()?,
                // };
                let data = token.data.data.try_as_bytes()?.as_ref().clone();

                Ok(Self {
                    status: ffi::TokenStatus::Ready,
                    action: ffi::TokenAction::Consume,
                    port_id: port_id.to_string(),
                    data,
                    timestamp: token.data.timestamp.get_time().as_u64(),
                })
            }
        }
    }
}

impl From<TokenAction> for ffi::TokenAction {
    fn from(action: TokenAction) -> Self {
        match action {
            TokenAction::Consume => ffi::TokenAction::Consume,
            TokenAction::Drop => ffi::TokenAction::Drop,
            TokenAction::KeepRun => ffi::TokenAction::Keep,
            TokenAction::Keep => ffi::TokenAction::Keep,
            TokenAction::Wait => ffi::TokenAction::Wait,
        }
    }
}

impl ffi::Input {
    fn from_data_message(
        port_id: &str,
        data_message: &zenoh_flow::runtime::message::DataMessage,
    ) -> ZFResult<Self> {
        let data = data_message.data.try_as_bytes()?.as_ref().clone();
        //  match &data_message.data{
        //     Data::Serialized(ser) => ser.as_ref().clone(),
        //     Data::Deserialized(de) => de.try_serialize()?,
        // };

        Ok(Self {
            port_id: port_id.to_string(),
            data,
            timestamp: data_message.timestamp.get_time().as_u64(),
        })
    }
}

pub struct MyOperator;

impl Node for MyOperator {
        fn initialize(
        &self,
        configuration: &Option<Configuration>,
    ) -> ZFResult<State> {
        let cxx_configuration = match configuration {
            Some(config) => match config.as_object() {
                Some(config) => {
                    let mut conf = vec![];
                    for (key, value) in config {
                        let entry =  ffi::Configuration {
                            key: key.clone(),
                            value: value.as_str().ok_or_else(|| ZFError::GenericError)?.to_string(),
                        };
                        conf.push(entry);
                    }
                    conf
                }
                None => vec![],
            }

            None => vec![],
        };

        let state = {
            #[allow(unused_unsafe)]
            unsafe {
                ffi::initialize(&cxx_configuration)
            }
        };
        Ok(State::from(StateWrapper { state }))
    }

    fn finalize(&self, _state: &mut State) -> ZFResult<()> {
        Ok(())
    }
}

impl Operator for MyOperator {
    fn input_rule(
        &self,
        context: &mut zenoh_flow::Context,
        dyn_state: &mut State,
        tokens: &mut HashMap<zenoh_flow::PortId, zenoh_flow::Token>,
    ) -> zenoh_flow::ZFResult<bool> {
        let wrapper = dyn_state.try_get::<StateWrapper>()?;
        let res_cxx_tokens: Result<Vec<ffi::Token>, ZFError> = tokens
            .iter_mut()
            .map(|(port_id, token)| ffi::Token::from_token(token, port_id))
            .collect();
        let mut cxx_tokens = res_cxx_tokens?;
        let mut cxx_context = ffi::Context::from(context);

        {
            #[allow(unused_unsafe)]
            unsafe {
                ffi::input_rule(&mut cxx_context, &mut wrapper.state, &mut cxx_tokens)
                    .map_err(|_| ZFError::GenericError)
            }
        }
    }

    fn run(
        &self,
        context: &mut zenoh_flow::Context,
        dyn_state: &mut State,
        inputs: &mut HashMap<zenoh_flow::PortId, zenoh_flow::runtime::message::DataMessage>,
    ) -> ZFResult<HashMap<zenoh_flow::PortId, Data>> {
        let mut cxx_context = ffi::Context::from(context);
        let wrapper = dyn_state.try_get::<StateWrapper>()?;
        let result_cxx_inputs: Result<Vec<ffi::Input>, ZFError> = inputs
            .iter_mut()
            .map(|(port_id, data_message)| ffi::Input::from_data_message(port_id, data_message))
            .collect();
        let cxx_inputs = result_cxx_inputs?;

        let cxx_outputs = {
            #[allow(unused_unsafe)]
            unsafe {
                ffi::run(&mut cxx_context, &mut wrapper.state, cxx_inputs)
                    .map_err(|_| ZFError::GenericError)?
            }
        };

        let mut result: HashMap<zenoh_flow::PortId, Data> =
            HashMap::with_capacity(cxx_outputs.len());
        for cxx_output in cxx_outputs.into_iter() {
            result.insert(cxx_output.port_id.into(), Data::from_bytes(cxx_output.data));
        }

        Ok(result)
    }

    fn output_rule(
        &self,
        _context: &mut zenoh_flow::Context,
        _dyn_state: &mut State,
        outputs: HashMap<zenoh_flow::PortId, Data>,
    ) -> ZFResult<HashMap<zenoh_flow::PortId, zenoh_flow::NodeOutput>> {
        let mut results = HashMap::with_capacity(outputs.len());
        // NOTE: default output rule for now.
        for (port_id, data) in outputs {
            results.insert(port_id, NodeOutput::Data(data));
        }

        Ok(results)
    }
}

zenoh_flow::export_operator!(register);

fn register() -> ZFResult<Arc<dyn Operator>> {
    Ok(Arc::new(MyOperator) as Arc<dyn Operator>)
}
